<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LocalDate]]></title>
      <url>http://karson.cc/2017/04/01/LocalDate/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[springmvc导出Excel问题记录]]></title>
      <url>http://karson.cc/2017/03/31/springmvcpost/</url>
      <content type="html"><![CDATA[<blockquote>
<p>SpringMVC中获取不到POST形式的参数<br>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何<br>对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。<br>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为<br>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。<br>但代码里强制使用了multipart/form-data方式。</p>
</blockquote>
<a id="more"></a>
<p>所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;       </div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></div></pre></td></tr></table></figure><br>并将commons-fileupload-1.3.2jar包引入到项目中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- POI导出Exl --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><br>这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。</p>
<p>注：此问题是在上一个项目<a href="https://coding.net/u/letra/p/mvcdemo/git" target="_blank" rel="external">git地址</a>的基础上新增了导出Ecxel功能是发现，在此记录一二。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IDEA+Maven+SpringMVC+Hibernate环境搭建]]></title>
      <url>http://karson.cc/2017/03/20/mvcdemo/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一篇十分详细的博文<a href="http://blog.lunhui.ren/archives/235" target="_blank" rel="external">地址</a><br><a href="https://git.coding.net/letra/MvcDemo.git" target="_blank" rel="external">源码地址</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Comparable 接口]]></title>
      <url>http://karson.cc/2017/03/15/Comparable/</url>
      <content type="html"><![CDATA[<p><img src="/img/articleImg/compare.png" alt=""></p>
<blockquote>
<p>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。<br><a id="more"></a></p>
</blockquote>
<h3 id="例1：通过重量排序苹果"><a href="#例1：通过重量排序苹果" class="headerlink" title="例1：通过重量排序苹果"></a>例1：通过重量排序苹果</h3><p>在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。</p>
<pre><code>Collections.sort(apples);
</code></pre><p>上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。<br>让我们开始写苹果类吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String variety;</div><div class="line">    <span class="keyword">private</span> Color color;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple other)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; other.weight) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.weight == other.weight) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。</p>
<h3 id="例2：通过多个特征排序苹果"><a href="#例2：通过多个特征排序苹果" class="headerlink" title="例2：通过多个特征排序苹果"></a>例2：通过多个特征排序苹果</h3><p>正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String variety;</div><div class="line">    <span class="keyword">private</span> Color color;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple other)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="keyword">this</span>.variety.compareTo(other.variety);</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">            result = <span class="keyword">this</span>.color.compareTo(other.color);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">            result = Integer.compare(<span class="keyword">this</span>.weight, other.weight);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(Apple other) &#123;</div><div class="line">     <span class="keyword">int</span> result = <span class="keyword">this</span>.variety.<span class="keyword">compareTo</span>(other.variety);</div><div class="line">     <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">          result = <span class="keyword">this</span>.color.<span class="keyword">compareTo</span>(other.color);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">          result = Integer.compare(<span class="keyword">this</span>.weight, other.weight);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。</p>
<h3 id="Comparable，hashCode以及Equals"><a href="#Comparable，hashCode以及Equals" class="headerlink" title="Comparable，hashCode以及Equals"></a>Comparable，hashCode以及Equals</h3><p>你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Map按值排序]]></title>
      <url>http://karson.cc/2017/03/15/mapSort/</url>
      <content type="html"><![CDATA[<h3 id="Map按值排序"><a href="#Map按值排序" class="headerlink" title="Map按值排序"></a>Map按值排序</h3><p>问题描述如下：</p>
<blockquote>
<p>现有Map<string,string>结构的数据，需要对其中包含的date值按降序排列输出<br>直观了解：<br>{<br>“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},<br>“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},<br>“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}<br>}<br>注：此Map的值也为String类型</string,string></p>
</blockquote>
<p>程序代码如下：<br><a id="more"></a><br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object MapSortTest(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span>) &#123;</div><div class="line"></div><div class="line">	<span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;&gt; resList=<span class="literal">new</span> ArrayList&lt;&gt;();</div><div class="line">      <span class="keyword">if</span>(!MapUtils.isEmpty(<span class="built_in">map</span>))&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//取Map映射集，遍历时可以getKey()，getValue()</span></div><div class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;&gt; entryList=<span class="literal">new</span> ArrayList&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;&gt;(<span class="built_in">map</span>.entrySet());</div><div class="line">	<span class="comment">//自定义比较器</span></div><div class="line">        Collections.sort(entryList, <span class="literal">new</span> Comparator&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;()&#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> int compare(<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; entry1, <span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; entry2) &#123;</div><div class="line"></div><div class="line">                 <span class="built_in">String</span> str1=entry1.getValue();</div><div class="line">                 <span class="built_in">String</span> str2=entry2.getValue();</div><div class="line">		<span class="comment">//切割截取date的值，subString前闭后开[)</span></div><div class="line">                 <span class="built_in">String</span> date1=str1.substring(str1.indexOf(<span class="string">":"</span>)+<span class="number">2</span>,str1.indexOf(<span class="string">","</span>)<span class="number">-1</span>);</div><div class="line">                 <span class="built_in">String</span> date2=str2.substring(str2.indexOf(<span class="string">":"</span>)+<span class="number">2</span>,str2.indexOf(<span class="string">","</span>)<span class="number">-1</span>);</div><div class="line">                   try &#123;</div><div class="line">                      <span class="built_in">Date</span> d1=DateUtils.parseDate(date1,<span class="string">"yyyy-MM-dd HH:mm:ss:SSS"</span>);</div><div class="line">                      <span class="built_in">Date</span> d2=DateUtils.parseDate(date2,<span class="string">"yyyy-MM-dd HH:mm:ss:SSS"</span>);</div><div class="line">			<span class="comment">//日期降序</span></div><div class="line">                      <span class="keyword">return</span> d2.compareTo(d1);</div><div class="line">                    &#125; catch (ParseException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">	     <span class="comment">//遍历排序后的映射集，封装返回</span></div><div class="line">            Iterator&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;&gt; iter=entryList.iterator();</div><div class="line">            <span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; temEntry =<span class="built_in">null</span>;</div><div class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</div><div class="line">                <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; sortedMap = <span class="literal">new</span> LinkedHashMap&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;();</div><div class="line">                temEntry=iter.next();</div><div class="line">                sortedMap.put(<span class="string">"type"</span>,temEntry.getKey());</div><div class="line">                sortedMap.put(<span class="string">"message"</span>,temEntry.getValue());</div><div class="line">                resList.add(sortedMap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resList;</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[connection holder is null]]></title>
      <url>http://karson.cc/2017/03/14/druidError/</url>
      <content type="html"><![CDATA[<blockquote>
<p>“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。<br>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。<br>而抛出“connection holder is null”异常的原因可能在于：<br>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000</p>
</blockquote>
<p>假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(holder ==<span class="literal">null</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (disableError != <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SQLException</span>(<span class="string">"connection holder is null"</span>, disableError);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SQLException</span>(<span class="string">"connection holder is null"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Lambda]]></title>
      <url>http://karson.cc/2017/03/13/Lambda/</url>
      <content type="html"><![CDATA[<p>Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。<br>在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。</p>
<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h2><p>Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。<br>Java 8中使用新特性Lambda表达式来改善这一点。<br><a id="more"></a></p>
<h3 id="1-1-使用示例"><a href="#1-1-使用示例" class="headerlink" title="1.1 使用示例"></a>1.1 使用示例</h3><p>以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。<br>使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(()-&gt;System.out.println(<span class="string">"Lambda"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></div></pre></td></tr></table></figure></p>
<h3 id="1-2-类型参数推断机制-Type-Argument-Inference"><a href="#1-2-类型参数推断机制-Type-Argument-Inference" class="headerlink" title="1.2 类型参数推断机制(Type Argument Inference)"></a>1.2 类型参数推断机制(Type Argument Inference)</h3><p>Lambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。</p>
<h3 id="1-3-函数接口-Functional-Interface"><a href="#1-3-函数接口-Functional-Interface" class="headerlink" title="1.3 函数接口(Functional Interface)"></a>1.3 函数接口(Functional Interface)</h3><p>一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。<br>Runnable的函数接口如下:<br><img src="/img/articleImg/jk82.png" alt=""><br>可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。<br>Java8中定义若干函数接口(位于包java.util.function)。<br><img src="/img/articleImg/jk8.png" alt=""><br>以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。</p>
<h3 id="1-4-并非语法糖"><a href="#1-4-并非语法糖" class="headerlink" title="1.4 并非语法糖"></a>1.4 并非语法糖</h3><p>从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Apple</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"apple"</span>;&#125;;</div><div class="line">	Runnable r1 = ()-&gt;&#123;System.<span class="keyword">out</span>.println(<span class="keyword">this</span>);&#125;;</div><div class="line">	Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			System.<span class="keyword">out</span>.println(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//执行两个线程得到的结果是</span></div><div class="line">apple</div><div class="line">Day0917.Apple$<span class="number">1</span>@<span class="number">22e90474</span></div></pre></td></tr></table></figure></p>
<pre><code>正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。
Lambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。
Lambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.
</code></pre><h3 id="1-5-默认方法"><a href="#1-5-默认方法" class="headerlink" title="1.5 默认方法"></a>1.5 默认方法</h3><p>Java8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Apple</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"interface"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApple</span> <span class="keyword">implements</span> <span class="title">Apple</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">		Apple.<span class="keyword">super</span>.show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。</p>
<h3 id="1-6-方法引用"><a href="#1-6-方法引用" class="headerlink" title="1.6 方法引用"></a>1.6 方法引用</h3><p>如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。<br>在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。</p>
<blockquote>
<p>//1,建立一个字符串<br>String::new<br>//2.建立一个字符串数组<br>String[]::new<br>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。</p>
</blockquote>
<h2 id="2-流stream"><a href="#2-流stream" class="headerlink" title="2.流stream"></a>2.流stream</h2><p>任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="type">ArrayList</span>&lt;<span class="type">String</span>&gt; person = <span class="function"><span class="keyword">new</span> <span class="title">ArrayList</span>&lt;&gt;();</span></div><div class="line">----<span class="title">init</span>----</div><div class="line"><span class="comment">//1.由集合获得流对象</span></div><div class="line"><span class="title">Stream</span>&lt;<span class="title">String</span>&gt; <span class="title">steam</span> = <span class="title">person</span>.<span class="title">stream</span>();</div><div class="line"><span class="comment">//2.对流对象进行过滤和统计</span></div><div class="line"><span class="title">steam</span>.<span class="title">filter</span>((s)-&gt;<span class="title">s</span>.<span class="title">startsWith</span>("a")) <span class="comment">//1.流过滤</span></div><div class="line">.<span class="title">count</span>(); <span class="comment">//2.计算流对象中元素数目</span></div></pre></td></tr></table></figure><br>使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T—&gt;boolean 的方法。<br>上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:<br>获得流对象Stream<br>对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。<br>对流对象Stream进行及早求值，返回值不在是一个Stream对象。</p>
<h3 id="2-1常见高阶函数"><a href="#2-1常见高阶函数" class="headerlink" title="2.1常见高阶函数"></a>2.1常见高阶函数</h3><h4 id="1-collect方法"><a href="#1-collect方法" class="headerlink" title="1.collect方法"></a>1.collect方法</h4><p>collect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。<br>这项工作由收集器Collector完成。java8为此提供了Collectors工具类。</p>
<h4 id="1-1-转换成集合"><a href="#1-1-转换成集合" class="headerlink" title="1.1 转换成集合"></a>1.1 转换成集合</h4><blockquote>
<p>List<person> list = stream.collect(Collectors.toList());<br>List<person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));<br>Set<person> set = stream.collect(Collectors.toSet());<br>Set<person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));</person></person></person></person></p>
</blockquote>
<p>使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；</p>
<h4 id="1-2-转换成值"><a href="#1-2-转换成值" class="headerlink" title="1.2 转换成值"></a>1.2 转换成值</h4><blockquote>
<p>//1.获得最大最小值<br>Function<person, integer=""> getLevel = p-&gt;p.age;<br>Comparator<person> comparator = Comparator.comparing(getLevel);<br>stream.collect(Collectors.maxBy(comparator));<br>stream.collect(Collectors.minBy(comparator));<br>//2.获得平均值<br>ToIntFunction<person> getAverage = p-&gt;p.age;<br>stream.collect(Collectors.averagingInt(getAverage));</person></person></person,></p>
</blockquote>
<h4 id="1-3-数据分块"><a href="#1-3-数据分块" class="headerlink" title="1.3 数据分块"></a>1.3 数据分块</h4><p>将流对象按某种条件分成两部分</p>
<blockquote>
<p>Predicate<person> isTang = p-&gt;p.country.equals(Country.Tang);<br>stream.collect(Collectors.partitioningBy(isTang));</person></p>
</blockquote>
<h4 id="1-4-数据分组"><a href="#1-4-数据分组" class="headerlink" title="1.4 数据分组"></a>1.4 数据分组</h4><blockquote>
<p>Function<person, integer=""> country= p -&gt; p.country.ordinal();<br>stream.collect(Collectors.groupingBy(country));</person,></p>
</blockquote>
<p>分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。</p>
<h4 id="1-5-字符串"><a href="#1-5-字符串" class="headerlink" title="1.5 字符串"></a>1.5 字符串</h4><blockquote>
<p>stream.map(Person::getName).collect(Collectors.joining(“/“, “[“, “]”));</p>
</blockquote>
<h4 id="1-6-合并收集器"><a href="#1-6-合并收集器" class="headerlink" title="1.6 合并收集器"></a>1.6 合并收集器</h4><blockquote>
<p>stream.collect(Collectors.groupingBy(country,Collectors.counting()));</p>
</blockquote>
<h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h3><p>map是一个惰性求值方法。函数接口为Function<t, r="">函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。</t,></p>
<h3 id="3-filter"><a href="#3-filter" class="headerlink" title="3.filter"></a>3.filter</h3><p>filter 是一个惰性求值方法。函数接口为Pridicate<t>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。</t></p>
<h3 id="4-flatMap系列"><a href="#4-flatMap系列" class="headerlink" title="4.flatMap系列"></a>4.flatMap系列</h3><p>flatMap 是一个惰性求值方法。其参数亦为Function<t, r="">,将多个流组合为一个流。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.a1,a2是两个列表，map处理后仍是两个列表</span></div><div class="line"><span class="selector-tag">Stream</span><span class="selector-class">.of</span>(a1,a2)<span class="selector-class">.map</span>(s-&gt;s)</div><div class="line"></div><div class="line"><span class="selector-attr">[1, 2, 3, 4]</span></div><div class="line"><span class="selector-attr">[]</span></div><div class="line"></div><div class="line"><span class="comment">//2.flatMap将二者合并为一个流</span></div><div class="line"><span class="selector-tag">Stream</span><span class="selector-class">.of</span>(a1,a2)<span class="selector-class">.map</span>(s-&gt;s)</div><div class="line"><span class="selector-class">.flatMap</span>(s-&gt;s.stream())</div></pre></td></tr></table></figure><br>1234<br>看源码可知，flatMap中函数接口Function的输出类型为Stream<r>。</r></t,></p>
<h3 id="5-max-min"><a href="#5-max-min" class="headerlink" title="5.max/min"></a>5.max/min</h3><p>属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。<br>min(Comparator.comparing(s-&gt;s.toString()));<br>max/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。</p>
<h3 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6.reduce"></a>6.reduce</h3><p>属于一个及早求值方法。意为流数据的累加，有两个版本。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span><span class="number">1.</span>无初始值累加</div><div class="line">T t = person.stream().reduce(<span class="function"><span class="params">(a,b)</span>-&gt;</span>a+b);</div><div class="line"><span class="regexp">//</span><span class="number">2.</span>带初始值累加</div><div class="line">Optional&lt;T&gt; t = person.stream().reduce(<span class="string">"1"</span>,<span class="function"><span class="params">(a,b)</span>-&gt;</span>a+b);</div></pre></td></tr></table></figure></p>
<h3 id="7-foreach"><a href="#7-foreach" class="headerlink" title="7.foreach"></a>7.foreach</h3><p>属于一个及早求值方法，用来遍历流对象。<br>总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo自动部署至VPS]]></title>
      <url>http://karson.cc/2017/03/03/webhook/</url>
      <content type="html"><![CDATA[<p>之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low~”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了~o(￣▽￣)o~ (小装一波~)。</p>
<blockquote>
<p>最终实现：自己电脑上新建文章后，hexo clean &amp;&amp; hexo g -d 即可。<br>实现原理：<br>1.hexo 提交代码渲染后文件至远程仓库(coding)<br>2.coding中对应项目配置webhook发送执行请求<br>3.vps 接收指定请求执行脚本(拉取最新代码)<br><a id="more"></a></p>
</blockquote>
<p>操作分为本机上和vps上的操作。</p>
<h3 id="hexo本地配置及部署"><a href="#hexo本地配置及部署" class="headerlink" title="hexo本地配置及部署"></a>hexo本地配置及部署</h3><blockquote>
<p>hexo是基于nodejs开发的，npm是nodejs的包管理工具<br>git用于部署代码<br>所以首页应确认本机环境：git，node.js环境<br>git,node.js安装可另查资料</p>
</blockquote>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#安装hexo命令行工具</span></div><div class="line">npm install hexo-cli -g</div><div class="line"><span class="meta">#创建blog目录，并初始化hexo项目</span></div><div class="line">hexo init blog</div><div class="line">cd blog</div><div class="line">hexo <span class="keyword">new</span> <span class="string">"My First Post"</span></div><div class="line"><span class="meta">#生成相关静态文件</span></div><div class="line">hexo g</div><div class="line"><span class="meta">#启动本地服务，查看效果（http://localhost:4000）</span></div><div class="line">hexo server</div></pre></td></tr></table></figure>
<p>hexo的git配置，hexo根目录下_config.yml文件中<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">deploy</span>:</div><div class="line">  <span class="attribute">type</span>: git</div><div class="line">  <span class="attribute">message</span>: update</div><div class="line">  <span class="attribute">repo</span>: git<span class="variable">@git</span>.coding.<span class="attribute">net</span>:letra/hexo.git </div></pre></td></tr></table></figure><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#代码部署</span></div><div class="line"><span class="attribute">hexo</span> deploy</div></pre></td></tr></table></figure><br>如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了<br>重点来了！！！</p>
<h3 id="远程仓库配置WebHooks"><a href="#远程仓库配置WebHooks" class="headerlink" title="远程仓库配置WebHooks"></a>远程仓库配置WebHooks</h3><p><img src="/img/articleImg/webhook.png" alt=""><br>这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到<a href="http://karson.cc:4002/webhooks/push/123456。">http://karson.cc:4002/webhooks/push/123456。</a></p>
<p>为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。</p>
<p>到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。</p>
<h3 id="VPS相关配置"><a href="#VPS相关配置" class="headerlink" title="VPS相关配置"></a>VPS相关配置</h3><p>在hexo目录中新建webhook.js,内容如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="keyword">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> exec = <span class="keyword">require</span>(<span class="string">'child_process'</span>).exec</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>&#123;</div><div class="line"><span class="comment">#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。</span></div><div class="line"><span class="keyword">if</span>(req.url === <span class="string">'/webhooks/push/123456'</span>)&#123;</div><div class="line"><span class="comment">#如果url匹配，表示认证通过，则执行 sh ./deploy.sh</span></div><div class="line">exec(<span class="string">'sh ./deploy.sh'</span>)</div><div class="line">&#125;</div><div class="line">res.end()</div><div class="line">&#125;).listen(<span class="number">4002</span>)</div></pre></td></tr></table></figure><br>这段代码就能启动一个nodejs服务，监听4002端口。<br>当请求过来的url完全匹配的时候，执行deploy.sh。<br>再新建一个文件deploy.sh处理部署相关脚本，内容如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin <span class="literal">master</span></div></pre></td></tr></table></figure><br>然后在服务器中启动nodejs服务监听webhooks<br>使用PM2执行脚本<a href="http://www.cnblogs.com/zhongweiv/p/pm2.html" target="_blank" rel="external">PM2</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> pm2 -g</div><div class="line">pm2 <span class="keyword">start</span> webhook.js</div></pre></td></tr></table></figure><br>然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下防御/减轻DDOS攻击]]></title>
      <url>http://karson.cc/2017/03/03/ddos/</url>
      <content type="html"><![CDATA[<p>好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。<br>登录后台就发现可能是被攻击了，导致被官方限制使用。<br><img src="/img/articleImg/vpsproblem.jpg" alt=""><br><a id="more"></a><br>被莫名的攻击后也是张二和尚摸不着头脑。<br>还能咋办叻?Goole~&amp;Baidu~<br>然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~</p>
<h2 id="DDoS-deflate介绍"><a href="#DDoS-deflate介绍" class="headerlink" title="DDoS deflate介绍"></a>DDoS deflate介绍</h2><blockquote>
<p>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过&gt;netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过<br>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.</p>
</blockquote>
<h3 id="如何确认是否受到DDOS攻击？"><a href="#如何确认是否受到DDOS攻击？" class="headerlink" title="如何确认是否受到DDOS攻击？"></a>如何确认是否受到DDOS攻击？</h3><p>由于我是直接重装了系统，所以这一步仅供参考<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -ntu | <span class="type">awk</span> '&#123;print $<span class="number">5</span>&#125;' | <span class="type">cut</span> -d: -f1 | <span class="type">sort</span> | <span class="type">uniq</span> -c | <span class="type">sort</span> -n</div></pre></td></tr></table></figure></p>
<p>据说：执行后，将会显示服务器上所有的每个IP多少个连接数。</p>
<h3 id="1-安装DDoS-deflate"><a href="#1-安装DDoS-deflate" class="headerlink" title="1.安装DDoS deflate"></a>1.安装DDoS deflate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="comment">//www.inetbase.com/scripts/ddos/install.sh   //下载DDoS  deflate</span></div><div class="line">chmod <span class="number">0700</span> install<span class="selector-class">.sh</span>    <span class="comment">//添加权限</span></div><div class="line">./install<span class="selector-class">.sh</span>             <span class="comment">//执行</span></div></pre></td></tr></table></figure>
<h3 id="2-配置DDoS-deflate"><a href="#2-配置DDoS-deflate" class="headerlink" title="2.配置DDoS deflate"></a>2.配置DDoS deflate</h3><p>DDoS deflate的默认配置位于/usr/local/ddos/ddos.conf<br>内容如下<br><img src="/img/articleImg/ddosconf.png" alt=""></p>
<p>查看/usr/local/ddos/ddos.sh文件的第117行<br>(vim模式下 跳转命令：行号 即可)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -ntu | awk ‘&#123;<span class="built_in">print</span> <span class="variable">$5</span>&#125;’ | cut <span class="_">-d</span>: <span class="_">-f</span>1 | sort | uniq -c | sort -nr &gt; <span class="variable">$BAD_IP_LIST</span></div></pre></td></tr></table></figure><br>修改为以下代码即可！<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -ntu | <span class="type">awk</span> ‘&#123;print $<span class="number">5</span>&#125;’ | <span class="type">cut</span> -d: -f1 | <span class="type">sed</span> -n ‘/[<span class="number">0</span><span class="number">-9</span>]/p’ | <span class="type">sort</span> | <span class="type">uniq</span> -c | <span class="type">sort</span> -nr &gt; $BAD_IP_LIST</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VPS安装及配置nginx]]></title>
      <url>http://karson.cc/2017/01/04/vps-install-nginx/</url>
      <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br><img src="/img/articleImg/nginx.jpg" alt=""><br><a id="more"></a></p>
<h2 id="环境确认"><a href="#环境确认" class="headerlink" title="环境确认"></a>环境确认</h2><p>系统环境：Centos 6<br>安装方式：源码编译安装 <a href="http://www.285868.com/a/xtjc/5635.html" target="_blank" rel="external">几种Linux软件的安装方法</a><br>安装位置：/usr/local/nginx</p>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>进入安装目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</div></pre></td></tr></table></figure></p>
<h3 id="安装pcre-用于Nginx的HTTP-Rewrite-模块"><a href="#安装pcre-用于Nginx的HTTP-Rewrite-模块" class="headerlink" title="安装pcre(用于Nginx的HTTP Rewrite 模块)"></a>安装pcre(用于Nginx的HTTP Rewrite 模块)</h3><blockquote>
<p>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。<br>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。</p>
</blockquote>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/<span class="keyword">local</span>/src </div><div class="line">wget ftp:<span class="comment">//ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz  	   </span></div><div class="line">tar -zxvf pcre<span class="number">-8.38</span>.tar.gz <span class="meta">#解压文件</span></div><div class="line">mv pcre<span class="number">-8.38</span>   pcre <span class="meta">#修改解压后文件夹名称</span></div><div class="line">cd pcre</div><div class="line">./configure 		<span class="meta">#准备编译</span></div><div class="line"><span class="built_in">make</span> &amp; <span class="built_in">make</span> install	<span class="meta">#编译及安装</span></div></pre></td></tr></table></figure>
<h3 id="安装zilb-一个压缩和解压模块"><a href="#安装zilb-一个压缩和解压模块" class="headerlink" title="安装zilb(一个压缩和解压模块)"></a>安装zilb(一个压缩和解压模块)</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src</div><div class="line">wget http://<span class="literal">zlib</span>.net/<span class="literal">zlib</span>-<span class="number">1.2</span>.<span class="number">8</span>.tar.gz</div><div class="line">tar -zxvf <span class="literal">zlib</span>-<span class="number">1.2</span>.<span class="number">8</span>.tar.gz</div><div class="line">mv <span class="literal">zlib</span>-<span class="number">1.2</span>.<span class="number">8</span> <span class="literal">zlib</span></div><div class="line">cd <span class="literal">zlib</span></div><div class="line">./configure</div><div class="line">make &amp; make install</div></pre></td></tr></table></figure>
<h3 id="安装SSl模块"><a href="#安装SSl模块" class="headerlink" title="安装SSl模块"></a>安装SSl模块</h3><blockquote>
<p>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。</p>
</blockquote>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /usr/<span class="keyword">local</span>/src</div><div class="line">wget http:<span class="comment">//www.openssl.org/source/openssl-1.0.1c.tar.gz</span></div><div class="line">tar -zxvf openssl<span class="number">-1.0</span><span class="number">.1</span>c.tar.gz</div><div class="line">mv openssl<span class="number">-1.0</span><span class="number">.1</span>c  openssl</div><div class="line">./config</div><div class="line"><span class="built_in">make</span> &amp; <span class="built_in">make</span> install</div></pre></td></tr></table></figure>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src</div><div class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz</div><div class="line">tar -zxvf nginx-1.9.9.tar.gz</div><div class="line">cd nginx-1.9.9</div><div class="line"></div><div class="line">./configure --sbin-path=/usr/local/nginx \</div><div class="line">-<span class="ruby">-conf-path=<span class="regexp">/usr/local</span><span class="regexp">/nginx/nginx</span>.conf \</span></div><div class="line">-<span class="ruby">-pid-path=<span class="regexp">/usr/local</span><span class="regexp">/nginx/nginx</span>.pid \</span></div><div class="line">-<span class="ruby">-with-http_ssl_module \</span></div><div class="line">-<span class="ruby">-with-http_v2_module \</span></div><div class="line">-<span class="ruby">-with-pcre=<span class="regexp">/usr/local</span><span class="regexp">/src/pcre</span> \</span></div><div class="line">-<span class="ruby">-with-zlib=<span class="regexp">/usr/local</span><span class="regexp">/src/zlib</span> \</span></div><div class="line">-<span class="ruby">-with-openssl=<span class="regexp">/usr/local</span><span class="regexp">/src/openssl</span></span></div><div class="line"></div><div class="line">make &amp; make install</div><div class="line"></div><div class="line">cd /usr/local/nginx #进入nginx目录</div><div class="line">nginx				#启动nginx</div></pre></td></tr></table></figure>
<p>启动后浏览器导航到<a href="http://IP" target="_blank" rel="external">http://IP</a> 就可以看到默认的欢迎界面了</p>
<h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nginx <span class="_">-s</span> stop停止nginx</div><div class="line">nginx 运行nginx</div><div class="line">nginx <span class="_">-s</span> reload 重启nginx</div><div class="line">nginx -t 测试nginx</div></pre></td></tr></table></figure>
<h3 id="nginx加入到环境变量"><a href="#nginx加入到环境变量" class="headerlink" title="nginx加入到环境变量"></a>nginx加入到环境变量</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vim</span> /etc/<span class="keyword">profile</span></div></pre></td></tr></table></figure>
<p>尾行添加<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PATH=<span class="variable">$PATH</span><span class="symbol">:/usr/local/nginx</span> <span class="comment">#nginx安装目录</span></div><div class="line">export PATH </div></pre></td></tr></table></figure><br>保存关闭后运行<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</div></pre></td></tr></table></figure></p>
<h3 id="修改网站默认根目录路径"><a href="#修改网站默认根目录路径" class="headerlink" title="修改网站默认根目录路径"></a>修改网站默认根目录路径</h3><blockquote>
<p>网站默认根目录放在/usr/local/nginx/html</p>
</blockquote>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="keyword">local</span>/nginx/<span class="keyword">conf</span>/nginx.<span class="keyword">conf</span></div></pre></td></tr></table></figure>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">server</span> &#123;</div><div class="line">	listen       <span class="number">80</span>;</div><div class="line">	server_name  你的IP;</div><div class="line">	<span class="meta">#charset koi8-r;</span></div><div class="line"></div><div class="line">	<span class="meta">#access_log  logs/host.access.log  main;</span></div><div class="line">	location / &#123;</div><div class="line">	root  /www/blog/<span class="keyword">public</span>;</div><div class="line">	<span class="keyword">index</span> <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</div><div class="line">	&#125;</div><div class="line">	.</div><div class="line">	.</div><div class="line">	.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>root添加自己想要的根目录，重启nginx生效。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VPS搭建多端口VPN]]></title>
      <url>http://karson.cc/2016/12/20/vps/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为了防止世界被破坏，为了守护世界的和平!<br>贯彻爱与真实的邪恶，可爱又迷人的反派角色!<br>世界辣么大~还不去看看！</p>
</blockquote>
<p><img src="/img/articleImg/naruto.jpg" alt=""><br><a id="more"></a></p>
<h2 id="所需"><a href="#所需" class="headerlink" title="所需"></a>所需</h2><p>1.他乡vps一台<br>2.xshell用于远程登录<br>3.shadowsocks应用程序。<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">点这里</a></p>
<h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready."></a>Ready.</h2><p>1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。<br>2.<a href="http://hostingset.com/" target="_blank" rel="external">购买VPS</a><br>3.打开xshell连接<br><img src="/img/articleImg/xshell.png" alt=""></p>
<h2 id="GO！！"><a href="#GO！！" class="headerlink" title="GO！！"></a>GO！！</h2><p>1.安装所需组件<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum <span class="keyword">install</span> m2crypto python-setuptools</div><div class="line">easy_install pip</div><div class="line">pip <span class="keyword">install</span> shadowsocks</div></pre></td></tr></table></figure></p>
<p>2.新建配置文件：shadowsocks.json<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"23.105.215.43"</span>,   <span class="comment">#你服务器的ip</span></div><div class="line">    <span class="string">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"local_port"</span>:<span class="number">1080</span>,</div><div class="line">    <span class="string">"port_password"</span>:&#123;           <span class="comment">#端口以及对应的密码</span></div><div class="line">         <span class="string">"9000"</span>:<span class="string">"password"</span>,</div><div class="line">         <span class="string">"9001"</span>:<span class="string">"password"</span>,</div><div class="line">         <span class="string">"9002"</span>:<span class="string">"password"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"timeout"</span>:<span class="number">300</span>,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"rc4-md5"</span>,         <span class="comment">#选择的加密方式</span></div><div class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>3添加<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks<span class="selector-class">.json</span></div><div class="line"></div><div class="line">ssserver -c /etc/shadowsocks<span class="selector-class">.json</span> -d start  #后台运行</div></pre></td></tr></table></figure><br>4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~<br>5.Android用户想要连接本文配置的vpn,请搜下图app.<br><img src="/img/articleImg/shadowsocks.png" alt=""></p>
]]></content>
    </entry>
    
  
  
</search>
