[{"title":"IDEA+Maven+SpringMVC+Hibernate环境搭建","date":"2017-03-20T06:09:10.000Z","path":"2017/03/20/mvcdemo/","text":"","tags":[{"name":"java","slug":"java","permalink":"http://karson.cc/tags/java/"}]},{"title":"Comparable 接口","date":"2017-03-15T08:37:39.000Z","path":"2017/03/15/Comparable/","text":"compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。 例1：通过重量排序苹果在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。 Collections.sort(apples); 上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。让我们开始写苹果类吧。123456789101112131415public class Apple implements Comparable &#123; private String variety; private Color color; private int weight; @Override public int compareTo(Apple other) &#123; if (this.weight &lt; other.weight) &#123; return -1; &#125; if (this.weight == other.weight) &#123; return 0; &#125; return 1; &#125;&#125;这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。 例2：通过多个特征排序苹果正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。12345678910111213141516171819202122public class Apple implements Comparable &#123; private String variety; private Color color; private int weight; @Override public int compareTo(Apple other) &#123; int result = this.variety.compareTo(other.variety); if (result != 0) &#123; return result; &#125; if (result == 0) &#123; result = this.color.compareTo(other.color); &#125; if (result != 0) &#123; return result; &#125; if (result == 0) &#123; result = Integer.compare(this.weight, other.weight); &#125; return result; &#125;&#125; 在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。1234567891011@Overridepublic int compareTo(Apple other) &#123; int result = this.variety.compareTo(other.variety); if (result == 0) &#123; result = this.color.compareTo(other.color); &#125; if (result == 0) &#123; result = Integer.compare(this.weight, other.weight); &#125; return result;&#125;正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。 Comparable，hashCode以及Equals你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。 结论在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。","tags":[{"name":"java","slug":"java","permalink":"http://karson.cc/tags/java/"},{"name":"comparable","slug":"comparable","permalink":"http://karson.cc/tags/comparable/"},{"name":"note","slug":"note","permalink":"http://karson.cc/tags/note/"}]},{"title":"Map按值排序","date":"2017-03-15T05:37:37.000Z","path":"2017/03/15/mapSort/","text":"Map按值排序问题描述如下： 现有Map结构的数据，需要对其中包含的date值按降序排列输出直观了解：{“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}}注：此Map的值也为String类型 程序代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142public Object MapSortTest(Map&lt;String, String&gt; map) &#123; List&lt;Map&lt;String,String&gt;&gt; resList=new ArrayList&lt;&gt;(); if(!MapUtils.isEmpty(map))&#123; //取Map映射集，遍历时可以getKey()，getValue() List&lt;Map.Entry&lt;String,String&gt;&gt; entryList=new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); //自定义比较器 Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;()&#123; @Override public int compare(Map.Entry&lt;String, String&gt; entry1, Map.Entry&lt;String, String&gt; entry2) &#123; String str1=entry1.getValue(); String str2=entry2.getValue(); //切割截取date的值，subString前闭后开[) String date1=str1.substring(str1.indexOf(\":\")+2,str1.indexOf(\",\")-1); String date2=str2.substring(str2.indexOf(\":\")+2,str2.indexOf(\",\")-1); try &#123; Date d1=DateUtils.parseDate(date1,\"yyyy-MM-dd HH:mm:ss:SSS\"); Date d2=DateUtils.parseDate(date2,\"yyyy-MM-dd HH:mm:ss:SSS\"); //日期降序 return d2.compareTo(d1); &#125; catch (ParseException e) &#123; e.printStackTrace(); return 0; &#125; &#125; &#125;); //遍历排序后的映射集，封装返回 Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter=entryList.iterator(); Map.Entry&lt;String,String&gt; temEntry =null; while (iter.hasNext())&#123; Map&lt;String,String&gt; sortedMap = new LinkedHashMap&lt;String,String&gt;(); temEntry=iter.next(); sortedMap.put(\"type\",temEntry.getKey()); sortedMap.put(\"message\",temEntry.getValue()); resList.add(sortedMap); &#125; &#125; return resList; &#125;说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。","tags":[{"name":"java","slug":"java","permalink":"http://karson.cc/tags/java/"},{"name":"note","slug":"note","permalink":"http://karson.cc/tags/note/"}]},{"title":"connection holder is null","date":"2017-03-14T02:58:24.000Z","path":"2017/03/14/druidError/","text":"“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。而抛出“connection holder is null”异常的原因可能在于：removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000 假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：12345678if(holder ==null) &#123; if (disableError != null) &#123; throw new SQLException(\"connection holder is null\", disableError); &#125; else &#123; throw new SQLException(\"connection holder is null\"); &#125; &#125;这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。","tags":[{"name":"java","slug":"java","permalink":"http://karson.cc/tags/java/"},{"name":"errors","slug":"errors","permalink":"http://karson.cc/tags/errors/"}]},{"title":"Lambda","date":"2017-03-13T07:23:43.000Z","path":"2017/03/13/Lambda/","text":"Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。 1.Lambda表达式Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。Java 8中使用新特性Lambda表达式来改善这一点。 1.1 使用示例以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。1new Thread(()-&gt;System.out.println(\"Lambda\")).start(); 1.2 类型参数推断机制(Type Argument Inference)Lambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。 1.3 函数接口(Functional Interface)一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。Runnable的函数接口如下:可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。Java8中定义若干函数接口(位于包java.util.function)。以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。 1.4 并非语法糖从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。123456789101112class Apple&#123; public String toString() &#123;return \"apple\";&#125;; Runnable r1 = ()-&gt;&#123;System.out.println(this);&#125;; Runnable r2 = new Runnable() &#123; public void run() &#123; System.out.println(this); &#125; &#125;;&#125;//执行两个线程得到的结果是appleDay0917.Apple$1@22e90474 正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。 Lambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。 Lambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final. 1.5 默认方法Java8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。1234567891011interface Apple&#123; default void show()&#123; System.out.println(\"interface\"); &#125;&#125;class MyApple implements Apple&#123; @Override public void show() &#123; Apple.super.show(); &#125;&#125;如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。 1.6 方法引用如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。 //1,建立一个字符串String::new//2.建立一个字符串数组String[]::new注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。 2.流stream任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:1234567ArrayList&lt;String&gt; person = new ArrayList&lt;&gt;();----init----//1.由集合获得流对象Stream&lt;String&gt; steam = person.stream();//2.对流对象进行过滤和统计steam.filter((s)-&gt;s.startsWith(\"a\")) //1.流过滤.count(); //2.计算流对象中元素数目使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T—&gt;boolean 的方法。上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:获得流对象Stream对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。对流对象Stream进行及早求值，返回值不在是一个Stream对象。 2.1常见高阶函数1.collect方法collect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。这项工作由收集器Collector完成。java8为此提供了Collectors工具类。 1.1 转换成集合 List list = stream.collect(Collectors.toList());List arraylist = stream.collect(Collectors.toCollection(ArrayList::new));Set set = stream.collect(Collectors.toSet());Set treeSet = stream.collect(Collectors.toCollection(TreeSet::new)); 使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型； 1.2 转换成值 //1.获得最大最小值Function getLevel = p-&gt;p.age;Comparator comparator = Comparator.comparing(getLevel);stream.collect(Collectors.maxBy(comparator));stream.collect(Collectors.minBy(comparator));//2.获得平均值ToIntFunction getAverage = p-&gt;p.age;stream.collect(Collectors.averagingInt(getAverage)); 1.3 数据分块将流对象按某种条件分成两部分 Predicate isTang = p-&gt;p.country.equals(Country.Tang);stream.collect(Collectors.partitioningBy(isTang)); 1.4 数据分组 Function country= p -&gt; p.country.ordinal();stream.collect(Collectors.groupingBy(country)); 分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。 1.5 字符串 stream.map(Person::getName).collect(Collectors.joining(“/“, “[“, “]”)); 1.6 合并收集器 stream.collect(Collectors.groupingBy(country,Collectors.counting())); 2.mapmap是一个惰性求值方法。函数接口为Function函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。 3.filterfilter 是一个惰性求值方法。函数接口为Pridicate,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。 4.flatMap系列flatMap 是一个惰性求值方法。其参数亦为Function,将多个流组合为一个流。123456789//1.a1,a2是两个列表，map处理后仍是两个列表Stream.of(a1,a2).map(s-&gt;s)[1, 2, 3, 4][]//2.flatMap将二者合并为一个流Stream.of(a1,a2).map(s-&gt;s).flatMap(s-&gt;s.stream())1234看源码可知，flatMap中函数接口Function的输出类型为Stream。 5.max/min属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。min(Comparator.comparing(s-&gt;s.toString()));max/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。 6.reduce属于一个及早求值方法。意为流数据的累加，有两个版本。1234//1.无初始值累加T t = person.stream().reduce((a,b)-&gt;a+b);//2.带初始值累加Optional&lt;T&gt; t = person.stream().reduce(\"1\",(a,b)-&gt;a+b); 7.foreach属于一个及早求值方法，用来遍历流对象。总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。","tags":[{"name":"java","slug":"java","permalink":"http://karson.cc/tags/java/"},{"name":"Lambda","slug":"Lambda","permalink":"http://karson.cc/tags/Lambda/"}]},{"title":"hexo自动部署至VPS","date":"2017-03-03T06:14:15.000Z","path":"2017/03/03/webhook/","text":"之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low~”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了~o(￣▽￣)o~ (小装一波~)。 最终实现：自己电脑上新建文章后，hexo clean &amp;&amp; hexo g -d 即可。实现原理：1.hexo 提交代码渲染后文件至远程仓库(coding)2.coding中对应项目配置webhook发送执行请求3.vps 接收指定请求执行脚本(拉取最新代码) 操作分为本机上和vps上的操作。 hexo本地配置及部署 hexo是基于nodejs开发的，npm是nodejs的包管理工具git用于部署代码所以首页应确认本机环境：git，node.js环境git,node.js安装可另查资料 12345678910#安装hexo命令行工具npm install hexo-cli -g#创建blog目录，并初始化hexo项目hexo init blogcd bloghexo new \"My First Post\"#生成相关静态文件hexo g#启动本地服务，查看效果（http://localhost:4000）hexo server hexo的git配置，hexo根目录下_config.yml文件中1234deploy: type: git message: update repo: git@git.coding.net:letra/hexo.git 12#代码部署hexo deploy如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了重点来了！！！ 远程仓库配置WebHooks这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到http://imlianer.com/webhooks/push/123456。 为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。 到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。 VPS相关配置在hexo目录中新建webhook.js,内容如下：12345678910var http = require('http')var exec = require('child_process').exechttp.createServer(function (req, res) &#123;#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。if(req.url === '/webhooks/push/123456')&#123;#如果url匹配，表示认证通过，则执行 sh ./deploy.shexec('sh ./deploy.sh')&#125;res.end()&#125;).listen(4002)这段代码就能启动一个nodejs服务，监听4002端口。当请求过来的url完全匹配的时候，执行deploy.sh。再新建一个文件deploy.sh处理部署相关脚本，内容如下：1git pull origin master然后在服务器中启动nodejs服务监听webhooks使用PM2执行脚本PM212npm install pm2 -gpm2 start webhook.js然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了…","tags":[{"name":"vps","slug":"vps","permalink":"http://karson.cc/tags/vps/"},{"name":"git","slug":"git","permalink":"http://karson.cc/tags/git/"},{"name":"webhook","slug":"webhook","permalink":"http://karson.cc/tags/webhook/"}]},{"title":"Linux下防御/减轻DDOS攻击","date":"2017-03-03T05:30:03.000Z","path":"2017/03/03/ddos/","text":"好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。登录后台就发现可能是被攻击了，导致被官方限制使用。被莫名的攻击后也是张二和尚摸不着头脑。还能咋办叻?Goole~&amp;Baidu~然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~ DDoS deflate介绍 DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过&gt;netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP. 如何确认是否受到DDOS攻击？由于我是直接重装了系统，所以这一步仅供参考1netstat -ntu | awk '&#123;print $5&#125;' | cut -d: -f1 | sort | uniq -c | sort -n 据说：执行后，将会显示服务器上所有的每个IP多少个连接数。 1.安装DDoS deflate123wget http://www.inetbase.com/scripts/ddos/install.sh //下载DDoS deflatechmod 0700 install.sh //添加权限./install.sh //执行 2.配置DDoS deflateDDoS deflate的默认配置位于/usr/local/ddos/ddos.conf内容如下 查看/usr/local/ddos/ddos.sh文件的第117行(vim模式下 跳转命令：行号 即可)1netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST修改为以下代码即可！1netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sed -n ‘/[0-9]/p’ | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST","tags":[{"name":"vps","slug":"vps","permalink":"http://karson.cc/tags/vps/"},{"name":"ddos","slug":"ddos","permalink":"http://karson.cc/tags/ddos/"}]},{"title":"VPS安装及配置nginx","date":"2017-01-04T05:43:14.000Z","path":"2017/01/04/vps-install-nginx/","text":"反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 环境确认系统环境：Centos 6安装方式：源码编译安装 几种Linux软件的安装方法安装位置：/usr/local/nginx 安装前提在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。 开始安装进入安装目录1cd /usr/local/src 安装pcre(用于Nginx的HTTP Rewrite 模块) 注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。 1234567cd /usr/local/src wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz tar -zxvf pcre-8.38.tar.gz #解压文件mv pcre-8.38 pcre #修改解压后文件夹名称cd pcre./configure #准备编译make &amp; make install #编译及安装 安装zilb(一个压缩和解压模块)1234567cd /usr/local/srcwget http://zlib.net/zlib-1.2.8.tar.gztar -zxvf zlib-1.2.8.tar.gzmv zlib-1.2.8 zlibcd zlib./configuremake &amp; make install 安装SSl模块 openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。 123456cd /usr/local/srcwget http://www.openssl.org/source/openssl-1.0.1c.tar.gztar -zxvf openssl-1.0.1c.tar.gzmv openssl-1.0.1c openssl./configmake &amp; make install 安装Nginx123456789101112131415161718cd /usr/local/srcwget http://nginx.org/download/nginx-1.9.9.tar.gztar -zxvf nginx-1.9.9.tar.gzcd nginx-1.9.9./configure --sbin-path=/usr/local/nginx \\--conf-path=/usr/local/nginx/nginx.conf \\--pid-path=/usr/local/nginx/nginx.pid \\--with-http_ssl_module \\--with-http_v2_module \\--with-pcre=/usr/local/src/pcre \\--with-zlib=/usr/local/src/zlib \\--with-openssl=/usr/local/src/opensslmake &amp; make installcd /usr/local/nginx #进入nginx目录nginx #启动nginx 启动后浏览器导航到http://IP 就可以看到默认的欢迎界面了 Nginx常用命令1234nginx -s stop停止nginxnginx 运行nginxnginx -s reload 重启nginxnginx -t 测试nginx nginx加入到环境变量1vim /etc/profile 尾行添加12PATH=$PATH:/usr/local/nginx #nginx安装目录export PATH 保存关闭后运行1source /etc/profile 修改网站默认根目录路径 网站默认根目录放在/usr/local/nginx/html 1vim /usr/local/nginx/conf/nginx.conf 1234567891011121314server &#123; listen 80; server_name 你的IP; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /www/blog/public; index index.html index.htm; &#125; . . .&#125; root添加自己想要的根目录，重启nginx生效。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://karson.cc/tags/nginx/"}]},{"title":"VPS搭建多端口VPN","date":"2016-12-20T08:37:45.000Z","path":"2016/12/20/vps/","text":"为了防止世界被破坏，为了守护世界的和平!贯彻爱与真实的邪恶，可爱又迷人的反派角色!世界辣么大~还不去看看！ 所需1.他乡vps一台2.xshell用于远程登录3.shadowsocks应用程序。点这里 Ready.1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。2.购买VPS3.打开xshell连接 GO！！1.安装所需组件123yum install m2crypto python-setuptoolseasy_install pippip install shadowsocks 2.新建配置文件：shadowsocks.json12345678910111213&#123; \"server\":\"23.105.215.43\", #你服务器的ip \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; #端口以及对应的密码 \"9000\":\"password\", \"9001\":\"password\", \"9002\":\"password\" &#125;, \"timeout\":300, \"method\":\"rc4-md5\", #选择的加密方式 \"fast_open\": false&#125;3添加123ssserver -c /etc/shadowsocks.jsonssserver -c /etc/shadowsocks.json -d start #后台运行4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~5.Android用户想要连接本文配置的vpn,请搜下图app.","tags":[{"name":"vps","slug":"vps","permalink":"http://karson.cc/tags/vps/"},{"name":"vpn","slug":"vpn","permalink":"http://karson.cc/tags/vpn/"}]}]